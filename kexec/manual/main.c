#define RW_BASE_PADDR									(void*)0x2FD600
#define RX_BASE_PADDR									((RW_BASE_PADDR)+4)
#define CUSTOM_KCODE_SYSCALL							(void*)0x00105000

#define KERNEL_RW										0x6020D006
#define KERNEL_RX										0x10F0D005
#define sceKernelAllocMemBlockForKernel_offset          0x26F258            // 0xB9D5EBDE
#define sceKernelMemcpyKernelToUser_offset              0x26F1E4
#define sceKernelMemcpyUserToKernel_offset              0x26f248            // 0xBC996A7A
#define sceKernelGetMemBlockBaseForKernel_offset        0x26f230            // 0xA841EDDA
#define sceKernelCpuUnrestrictedMemcpy_offset           0x26f808            // 0x8C683DEC 

#define DECLARE_KFUNCS()								void (*prnt)(const char*, ...) = (void*)(0x8100FFA8);							\
														int (*sceIoOpen)(const char*, int, int) = (void*)(0x81010058);					\
														int (*sceIoRead)(int, void*, int) = (void*)(0x81010068);						\
														int (*sceIoClose)(int) = (void*)(0x81010148);									\
														int (*my_syscall)(void*, void*, void*, void*, unsigned int) = (void*)(0x81000088)

struct SceKernelAllocMemKernelBlockOpt {
	int size; 
	int unk;
	int attr;
	int unk2;
	int paddr;
	int align;
	int unk3[3];
	int processid;
};

inline static void DumpHex(const void* data, int size);
inline static void memset(char* a, char b, int len);

inline unsigned int calc_syscall_addr(unsigned int tbl, unsigned int kaddr)
{
	unsigned int val;
	val = kaddr - tbl;
	val &= 0xFFFFFFFF;
	val /= 4;
	val +=0x100;
	return val;
}

inline unsigned int get_syscall_tbl() {
	DECLARE_KFUNCS();
	return my_syscall(0, 0, 0, 0, 0x400000FF);
}
inline int sceKernelAllocMemBlockForKernel(char* name, int type, int size, struct SceKernelAllocMemKernelBlockOpt* opt)
{
	DECLARE_KFUNCS();
	return my_syscall(name, (void*)type, (void*)size, opt, calc_syscall_addr(get_syscall_tbl(), sceKernelAllocMemBlockForKernel_offset));
}
inline int sceKernelMemcpyUserToKernel(void* dest, void* source, int size)
{
	DECLARE_KFUNCS();
	return my_syscall(dest, source, (void*)size, 0, calc_syscall_addr(get_syscall_tbl(), sceKernelMemcpyUserToKernel_offset));
}
inline int sceKernelMemcpyKernelToUser(void* dest, void* source, int size)
{
	DECLARE_KFUNCS();
	return my_syscall(dest, source, (void*)size, 0, calc_syscall_addr(get_syscall_tbl(), sceKernelMemcpyKernelToUser_offset));
}
inline int sceKernelGetMemBlockBaseForKernel(int block, void* baseaddr)
{
	DECLARE_KFUNCS();
	return my_syscall((void*)block, baseaddr, 0, 0, calc_syscall_addr(get_syscall_tbl(), sceKernelGetMemBlockBaseForKernel_offset));
}
inline int sceKernelCpuUnrestrictedMemcpy(void* dest, void* source, int size)
{
	DECLARE_KFUNCS();
	return my_syscall(dest, source, (void*)size, 0, calc_syscall_addr(get_syscall_tbl(), sceKernelCpuUnrestrictedMemcpy_offset));
} 

inline void execute_payload(int tbl, char* payload_path) 
{
	DECLARE_KFUNCS();

	unsigned char buffer[0x6000];
	memset(buffer, 0x00, 0x6000);

	int fd = sceIoOpen(payload_path, 1, 1);
	if (fd) {
		sceIoRead(fd, buffer, 0x6000);
		sceIoClose(fd);
	} else {
		prnt("Couldn't open '%s'\n", payload_path);
		return;
	}

	int res = 0, baseaddr = 0, rwbaseuser = 0, rxbaseuser = 0;

	res = sceKernelAllocMemBlockForKernel("", KERNEL_RW, 0x6000, (struct SceKernelAllocMemKernelBlockOpt*)0);
	prnt("[RW] sceKernelAllocMemBlockForKernel: 0x%X\n", res);

	res = sceKernelGetMemBlockBaseForKernel(res, RW_BASE_PADDR);
	prnt("[RW] sceKernelGetMemBlockBaseForKernel: 0x%X\n", res);

	sceKernelMemcpyKernelToUser(&baseaddr, RW_BASE_PADDR, 4);
	prnt("[-] Base Address for RW mem: 0x%08X\n", baseaddr);
	rwbaseuser = baseaddr;

	sceKernelMemcpyUserToKernel((void*)rwbaseuser, (void*)buffer, 0x6000);

	res = sceKernelAllocMemBlockForKernel("", KERNEL_RX, 0x6000, (struct SceKernelAllocMemKernelBlockOpt*)0);//0x10000100);
	prnt("[RX] sceKernelAllocMemBlockForKernel: 0x%08X\n", res);

	res = sceKernelGetMemBlockBaseForKernel(res, (void*)RX_BASE_PADDR);
	prnt("[RX] sceKernelGetMemBlockBaseForKernel: 0x%08X\n", res);

	sceKernelMemcpyKernelToUser(&rxbaseuser, (void*)RX_BASE_PADDR, 4);
	prnt("[-] Base Address for RX: 0x%08X\n", rxbaseuser);

	sceKernelCpuUnrestrictedMemcpy((void*)rxbaseuser, (void*)rwbaseuser, 0x6000);
	prnt("[-] copied code into rx\n");
	rxbaseuser |= 1;

	sceKernelMemcpyUserToKernel(CUSTOM_KCODE_SYSCALL, (void*)&rxbaseuser, 4);

	prnt("[-] custom kernel code returned 0x%x\n", my_syscall(0, 0, 0, 0, calc_syscall_addr(tbl, CUSTOM_KCODE_SYSCALL)));
	return;
}

int user_start(int size, void* argp)
{
	DECLARE_KFUNCS();

	int ret = 0;
	int syscall_tbl = get_syscall_tbl();
	prnt("Hello!\nHello Syscall Table! 0x%08x\n", syscall_tbl);
	
	execute_payload(syscall_tbl, "host0:kpayload.bin");
	
	while (1);		
	return ret;
}

void memset(char* a, char b, int len) {
	for(int i=0; i<len; ++i)
		a[i] = b;
}
void DumpHex(const void* data, int size) {
	DECLARE_KFUNCS();
	char ascii[17];
	int i, j;
	ascii[16] = '\0';
	for (i = 0; i < size; ++i) {
		prnt("%02X ", ((unsigned char*)data)[i]);
		if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
			ascii[i % 16] = ((unsigned char*)data)[i];
		} else {
			ascii[i % 16] = '.';
		}
		if ((i+1) % 8 == 0 || i+1 == size) {
			prnt(" ");
			if ((i+1) % 16 == 0) {
				prnt("|  %s \n", ascii);
			} else if (i+1 == size) {
				ascii[(i+1) % 16] = '\0';
				if ((i+1) % 16 <= 8) {
					prnt(" ");
				}
				for (j = (i+1) % 16; j < 16; ++j) {
					prnt("   ");
				}
				prnt("|  %s \n", ascii);
			}
		}
	}
}